#!/usr/bin/env python
# -*- mode: python; coding: utf-8 -*-

"""Parsing model, which includes the following functions
1. Mini-batch training on the data generated by the Data class
2. Shift-Reduce RST parsing for a given text sequence
3. Save/load parsing model

"""

##################################################################
# Imports
from __future__ import absolute_import, print_function, unicode_literals

from six import iteritems
from sklearn.pipeline import Pipeline
from sklearn.feature_extraction import DictVectorizer
from sklearn.svm import LinearSVC
import numpy as np

from .feature import FeatureExtractor
from .utils import LOGGER


##################################################################
# Constants
DFLT_C = 0.02
DFLT_CLS_WGHT = None
DFLT_PARAMS = {"class_weight": DFLT_CLS_WGHT, "loss": "hinge",
               "penalty": "l1", "dual": True, "multi_class": "crammer_singer"}


##################################################################
# Classes
class Model(object):
    def __init__(self, clf=None):
        """ Initialization

        :type clf: LinearSVC
        :param clf: a multiclass classifier or None
        """
        classifier = clf or LinearSVC(C=DFLT_C, **DFLT_PARAMS)
        self._clf = Pipeline([("vect", DictVectorizer()),
                              ("clf", classifier)])
        self._feat_extractor = FeatureExtractor()
        self._matrix = None
        self._action2idx = {}
        self._idx2action = {}

    def reset(self):
        """Set all unpickable components to None.

        """
        pass

    def restore(self):
        """Restore all components that were reset at pickling.

        """
        pass

    def train(self, train_x, train_y, grid_search=False):
        """ Perform batch-learning on parsing model.

        :param list[tuple] x: list of training instances (3-tuples)
        :param list[tuple] y: list of gold classes
        :param bool grid_search: use grid search to optimize hyper-parameters

        """
        LOGGER.debug("Training internal model...")
        # extract features
        train_x = [self._feat_extractor.extract_feats(*x_i) for x_i in train_x]
        train_y = self._digitize_labels(train_y)
        train_x, train_y, dev_x, dev_y = self._split_data(train_x, train_y)
        self._clf.fit(train_x, train_y)
        LOGGER.debug("Internal model trained...")

    def predict(self, seg1, seg2, seg3):
        """Predict parsing action for a given set of features.

        """
        feats = self.extract_features()
        predicted_output = self.clf.decision_function(feats)
        idxs = np.argsort(predicted_output[0])[::-1]
        return idxs

    def _digitize_labels(self, train_y):
        """Convert action tuples to indices.

        :param list[tuple] train_y: originl list of action tuples

        :return: list of indices

        """
        ret = []
        for action_i in train_y:
            if action_i not in self._action2idx:
                self._action2idx[action_i] = len(self._action2idx)
            ret.append(self._action2idx[action_i])
        self._idx2action = {v: k for k, v in iteritems(self._action2idx)}
        return ret

    def _split_data(self, train_x, train_y):
        """Provide train/test split and digitize data.

        """
        n = len(train_x)
        n_dev = int(n / 15)
        idcs = list(range(n))
        np.random.shuffle(idcs)

        def get_split(data, idcs):
            return [data[i] for i in idcs]

        dev_x = get_split(train_x, idcs[:n_dev])
        dev_y = get_split(train_y, idcs[:n_dev])
        train_x = get_split(train_x, idcs[n_dev:])
        train_y = get_split(train_y, idcs[n_dev:])
        return train_x, train_y, dev_x, dev_y
